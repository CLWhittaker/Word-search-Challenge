<!-- This is a shortened preview. The full code includes:
- Directional tracing logic (start and end click)
- Word validation across 8 directions
- Local storage to save found words
- Lore captions and final banner reveal
-->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>The Scroll of Monumental Mayhem</title>
  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      text-align: center;
      background: #fdf6e3;
      color: #333;
    }
    #grid {
      margin: 20px auto;
      border-collapse: collapse;
    }
    #grid td {
      width: 24px;
      height: 24px;
      border: 1px solid #ccc;
      text-align: center;
      font-size: 16px;
      cursor: pointer;
    }
    .selected {
      background-color: #cce5ff;
    }
    .found {
      background-color: #b2f2bb;
      font-weight: bold;
    }
    .foundWord {
      text-decoration: line-through;
      color: #999;
    }
    #banner {
      display: none;
      margin-top: 20px;
      font-size: 18px;
      color: #007700;
    }
    .caption {
      margin-top: 10px;
      font-style: italic;
    }
  </style>
</head>
<body>
  <h1>The Scroll of Monumental Mayhem</h1>
  <p>Click and drag to trace a word. Progress is saved.</p>
  <div id="wordList"></div>
  <table id="grid"></table>
  <div id="banner">üß¶ You‚Äôve earned your ceremonial socks and scrollsmith badge. Onward to the next ritual.</div>
  <div id="captions"></div>

  <script>
    const gridSize = 22;
    
 const words = {
  ACADEME: "Where scrolls are born and pedants duel in dusty silence.",
  ACCUSED: "Marked by whispers, but not yet claimed by truth.",
  AMAZEMENT: "The gasp that follows a moonbeam‚Äôs unexpected arrival.",
  COMPROMISE: "A handshake between chaos and calm, sealed with ceremonial socks.",
  DEAFENING: "The silence that screams louder than any outbreak.",
  GNARLED: "Twisted by time, but still rooted in ritual.",
  LAUGHABLE: "When the absurd becomes sacred and socks become scrolls.",
  MADCAP: "The jester‚Äôs sprint through monumental mayhem.",
  MAJESTIC: "Crowned not by gold, but by resilience and mismatched laundry.",
  MIMIC: "A chest you don‚Äôt want to find.",
  MONUMENTAL: "Built from grief, grit, and the bones of canceled plans.",
  MOONBEAM: "A soft rebellion against remorseless nights.",
  NOISELESS: "The hush before the banner rises.",
  OBSCENE: "Too raw for academe, too real for denial.",
  OUTBREAK: "The ritual of masks, scrolls, and sudden pivots.",
  PANDERS: "Whispers that flatter, but never inscribe.",
  PEDANT: "Keeper of rules, challenger of lore.",
  RADIANCE: "The glow that follows a found word.",
  SWAGGER: "The strut of survival in socked feet.",
  REMORSELESS: "Unyielding as grief, sacred as scrollsmith fire."
};


    const puzzle = Array(gridSize * gridSize).fill(null);
    const grid = document.getElementById("grid");
    const captionsDiv = document.getElementById("captions");
    const wordListDiv = document.getElementById("wordList");
    let foundWords = JSON.parse(localStorage.getItem("foundWords")) || [];
    let isDragging = false;
    let selectionPath = [];

    function renderWordList() {
      wordListDiv.innerHTML = "<strong>Words to Find:</strong><br>" + Object.keys(words).map(word => {
        return `<span id="word-${word}" class="${foundWords.includes(word) ? 'foundWord' : ''}">${word}</span>`;
      }).join(", ");
    }

    function updateWordList(word) {
  const el = document.getElementById(`word-${word}`);
  if (el) el.classList.add("foundWord");
}
  function placeWord(word, maxAttempts = 500) {
  const directions = [
    [0, 1],   // right
    [1, 0],   // down
    [1, 1],   // down-right
    [-1, 1]   // up-right
  ];
  for (let attempt = 0; attempt < maxAttempts; attempt++) {
    const dir = directions[Math.floor(Math.random() * directions.length)];
    const row = Math.floor(Math.random() * gridSize);
    const col = Math.floor(Math.random() * gridSize);
    let fits = true;
    for (let i = 0; i < word.length; i++) {
      const r = row + dir[0] * i;
      const c = col + dir[1] * i;
      const index = r * gridSize + c;
      if (
        r < 0 || r >= gridSize || c < 0 || c >= gridSize ||
        (puzzle[index] && puzzle[index] !== word[i])
      ) {
        fits = false;
        break;
      }
    }
    if (fits) {
      for (let i = 0; i < word.length; i++) {
        const r = row + dir[0] * i;
        const c = col + dir[1] * i;
        const index = r * gridSize + c;
        puzzle[index] = word[i];
      }
      return true;
    }
  }
  return false;
}
const unplaced = [];

Object.keys(words).forEach(word => {
  const success = placeWord(word);
  if (!success) {
    unplaced.push(word);
    console.warn(`‚ö†Ô∏è Failed to place: ${word}`);
  }
});

unplaced.forEach(word => {
  const success = placeWord(word, 1000);
  if (!success) {
    console.error(`‚ùå Still failed to place: ${word}`);
  }
});

fillEmptyCells();                      // Fill remaining gaps
renderGrid();                          // Display the puzzle
renderWordList();                      // Show word list
foundWords.forEach(updateWordList);   // Restore progress

    function fillEmptyCells() {
  for (let i = 0; i < puzzle.length; i++) {
    if (!puzzle[i]) {
      puzzle[i] = String.fromCharCode(65 + Math.floor(Math.random() * 26));
    }
  }
}

function renderGrid() {
  for (let i = 0; i < gridSize; i++) {
    const tr = document.createElement("tr");
    for (let j = 0; j < gridSize; j++) {
      const td = document.createElement("td");
      const index = i * gridSize + j;
      td.textContent = puzzle[index];
      td.dataset.row = i;
      td.dataset.col = j;
      td.addEventListener("mousedown", () => handleMouseDown(td));
      td.addEventListener("mouseover", () => handleMouseOver(td));
      td.addEventListener("mouseup", handleMouseUp);
      tr.appendChild(td);
    }
    grid.appendChild(tr);
  }
}

function handleMouseDown(cell) {
  isDragging = true;
  selectionPath = [cell];
  cell.classList.add("selected");
}

function handleMouseOver(cell) {
  if (!isDragging || selectionPath.includes(cell)) return;
  selectionPath.push(cell);
  cell.classList.add("selected");
}

function handleMouseUp() {
  if (selectionPath.length < 2) {
    selectionPath = [];
    return;
  }

  const getCoords = cell => {
    const index = Array.from(grid.children).indexOf(cell);
    return [Math.floor(index / gridSize), index % gridSize];
  };

  const [startRow, startCol] = getCoords(selectionPath[0]);
  const [nextRow, nextCol] = getCoords(selectionPath[1]);
  const dirRow = nextRow - startRow;
  const dirCol = nextCol - startCol;

  // Normalize direction to unit steps
  const stepRow = Math.sign(dirRow);
  const stepCol = Math.sign(dirCol);

  // Validate all cells follow the same direction
  let valid = true;
  for (let i = 1; i < selectionPath.length; i++) {
    const [prevRow, prevCol] = getCoords(selectionPath[i - 1]);
    const [currRow, currCol] = getCoords(selectionPath[i]);
    const deltaRow = currRow - prevRow;
    const deltaCol = currCol - prevCol;
    if (deltaRow !== stepRow || deltaCol !== stepCol) {
      valid = false;
      break;
    }
  }

  if (valid) {
    const word = selectionPath.map(c => c.textContent).join("");
    const reversed = word.split("").reverse().join("");
    const found = Object.keys(words).find(w => w === word || w === reversed);
    if (found && !foundWords.includes(found)) {
      foundWords.push(found);
      localStorage.setItem("foundWords", JSON.stringify(foundWords));
      updateWordList(found);
    }
  }

  selectionPath = [];
}

document.body.onmousedown = () => false;
 
fillEmptyCells();
renderGrid();
renderWordList();
foundWords.forEach(updateWordList);

      </script>
</body>
</html>

