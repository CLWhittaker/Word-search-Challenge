<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>The Scroll of Monumental Mayhem</title>
  <style>
    body {
      font-family: 'Courier New', monospace;
      background-color: #fdf6e3;
      color: #333;
      text-align: center;
      padding: 20px;
    }
    h1 {
      font-size: 2em;
      margin-bottom: 10px;
    }
    table {
      margin: 0 auto;
      border-collapse: collapse;
    }
    td {
      width: 30px;
      height: 30px;
      text-align: center;
      border: 1px solid #999;
      font-weight: bold;
      cursor: pointer;
    }
    .selected {
      background-color: #c6f6d5;
    }
    .found {
      background-color: #81e6d9;
    }
    #banner {
      display: none;
      margin-top: 20px;
      font-size: 1.5em;
      color: #2c5282;
    }
    .caption {
      font-size: 0.9em;
      margin-top: 5px;
      color: #555;
    }
    #wordList {
      margin-top: 20px;
      font-size: 1em;
      color: #444;
    }
    .foundWord {
      text-decoration: line-through;
      color: #888;
    }
  </style>
</head>
<body>
  <h1>The Scroll of Monumental Mayhem</h1>
  <p>Click letters to select words. Find all 20 to reveal the banner.</p>
  <div id="wordList"></div>
  <table id="grid"></table>
  <div id="banner">ðŸ§¦ Youâ€™ve earned your ceremonial socks and scrollsmith badge. Onward to the next ritual.</div>
  <div id="captions"></div>

  <script>
    const words = {
      ACADEME: "Where scrolls are born and pedants duel in dusty silence.",
      ACCUSED: "Marked by whispers, but not yet claimed by truth.",
      AMAZEMENT: "The gasp that follows a moonbeamâ€™s unexpected arrival.",
      COMPROMISE: "A handshake between chaos and calm, sealed with ceremonial socks.",
      DEAFENING: "The silence that screams louder than any outbreak.",
      GNARLED: "Twisted by time, but still rooted in ritual.",
      LAUGHABLE: "When the absurd becomes sacred and socks become scrolls.",
      MADCAP: "The jesterâ€™s sprint through monumental mayhem.",
      MAJESTIC: "Crowned not by gold, but by resilience and mismatched laundry.",
      MIMIC: "A chest you donâ€™t want to find.",
      MONUMENTAL: "Built from grief, grit, and the bones of canceled plans.",
      MOONBEAM: "A soft rebellion against remorseless nights.",
      NOISELESS: "The hush before the banner rises.",
      OBSCENE: "Too raw for academe, too real for denial.",
      OUTBREAK: "The ritual of masks, scrolls, and sudden pivots.",
      PANDERS: "Whispers that flatter, but never inscribe.",
      PEDANT: "Keeper of rules, challenger of lore.",
      RADIANCE: "The glow that follows a found word.",
      SWAGGER: "The strut of survival in socked feet.",
      REMORSELESS: "Unyielding as grief, sacred as scrollsmith fire."
    };

    const gridSize = 25;
    const grid = Array.from({ length: gridSize }, () => Array(gridSize).fill(''));
    const table = document.getElementById("grid");
    const captionsDiv = document.getElementById("captions");
    const wordListDiv = document.getElementById("wordList");
    let foundWords = [];

    function renderWordList() {
      wordListDiv.innerHTML = "<strong>Words to Find:</strong><br>" + Object.keys(words).map(word => {
        return `<span id="word-${word}">${word}</span>`;
      }).join(", ");
    }

    function updateWordList(word) {
      const el = document.getElementById(`word-${word}`);
      if (el) el.classList.add("foundWord");
    }

    function placeWord(word) {
      const directions = [[0,1],[1,0],[1,1],[-1,1],[0,-1],[-1,0],[-1,-1],[1,-1]];
      for (let attempt = 0; attempt < 200; attempt++) {
        const dir = directions[Math.floor(Math.random() * directions.length)];
        const row = Math.floor(Math.random() * gridSize);
        const col = Math.floor(Math.random() * gridSize);
        let fits = true;
        for (let i = 0; i < word.length; i++) {
          const r = row + dir[0] * i;
          const c = col + dir[1] * i;
          if (r < 0 || r >= gridSize || c < 0 || c >= gridSize || (grid[r][c] && grid[r][c] !== word[i])) {
            fits = false;
            break;
          }
        }
        if (fits) {
          for (let i = 0; i < word.length; i++) {
            const r = row + dir[0] * i;
            const c = col + dir[1] * i;
            grid[r][c] = word[i];
          }
          return;
        }
      }
    }

    Object.keys(words).forEach(word => placeWord(word));

    for (let i = 0; i < gridSize; i++) {
      for (let j = 0; j < gridSize; j++) {
        if (!grid[i][j]) {
          grid[i][j] = String.fromCharCode(65 + Math.floor(Math.random() * 26));
        }
      }
    }

    grid.forEach((row, i) => {
      const tr = document.createElement("tr");
      row.forEach((letter, j) => {
        const td = document.createElement("td");
        td.textContent = letter;
        td.dataset.row = i;
        td.dataset.col = j;
        td.addEventListener("click", () => {
          td.classList.toggle("selected");
          checkWords();
        });
        tr.appendChild(td);
      });
      table.appendChild(tr);
    });

    function checkWords() {
      Object.keys(words).forEach(word => {
        const positions = [];
        for (let i = 0; i < gridSize; i++) {
          for (let j = 0; j < gridSize; j++) {
            for (let d of [[0,1],[1,0],[1,1],[-1,1],[0,-1],[-1,0],[-1,-1],[1,-1]]) {
              let match = true;
              positions.length = 0;
              for (let k = 0; k < word.length; k++) {
                const r = i + d[0]*k;
                const c = j + d[1]*k;
                if (r < 0 || r >= gridSize || c < 0 || c >= gridSize) {
                  match = false;
                  break;
                }
                const cell = document.querySelector(`td[data-row='${r}'][data-col='${c}']`);
                if (!cell || !cell.classList.contains("selected") || cell.textContent !== word[k]) {
                  match = false;
                  break;
                }
                positions.push(cell);
              }
              if (match && !foundWords.includes(word)) {
                foundWords.push(word);
                positions.forEach(cell => {
                  cell.classList.remove("selected");
                  cell.classList.add("found");
                });
                const caption = document.createElement("div");
                caption.className = "caption";
                caption.textContent = `${word}: ${words[word]}`;
                captionsDiv.appendChild(caption);
                updateWordList(word);
                checkCompletion();
              }
            }
          }
        }
      });
    }

    function checkCompletion() {
      if (foundWords.length === Object.keys(words).length) {
        document.getElementById("banner").style.display = "block";
      }
    }

    renderWordList();
  </script>
</body>
</html>

