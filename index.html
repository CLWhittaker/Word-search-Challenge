<!-- This is a shortened preview. The full code includes:
- Directional tracing logic (start and end click)
- Word validation across 8 directions
- Local storage to save found words
- Lore captions and final banner reveal
-->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>The Scroll of Monumental Mayhem</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      text-align: center;
      background: #fdf6e3;
      color: #333;
      touch-action: manipulation;
    }
    #grid {
      margin: 20px auto;
      border-collapse: collapse;
    }
@media (max-width:600px){
   #grid td {
  width: 25px;
  height: 25px;
  border: none;
  text-align: center;
  font-size: 14px;
  cursor: pointer;
  touch-action: manipulation;
  pointer-events: auto;
  }
    }
    .selected {
      background-color: #cce5ff;
    }
    .found {
      background-color: #b2f2bb;
      font-weight: bold;
    }
    .foundWord {
      text-decoration: line-through;
      color: #999;
    }
   #gridWrapper {
  overflow-x: auto;
  max-width: 100vw;
  margin: 0 auto;
  touch-action: auto;
}


#grid {
  display: block;
  width: max-content;
}

    #banner {
      display: none;
      margin-top: 20px;
      font-size: 18px;
      color: #007700;
    }
    .caption {
      margin-top: 10px;
      font-style: italic;
    }
  </style>
</head>
<body>
  <h1>The Scroll of Monumental Mayhem</h1>
  <p>Click and drag to trace a word. Progress is saved.</p>
  <div id="wordList"></div>
   <div id="gridWrapper">
  <table id="grid"></table>
</div>


<div id="banner" style="display: none;">
  üß¶ You‚Äôve earned your ceremonial socks and scrollsmith badge. Onward to the next ritual.
</div>
  <button onclick="resetScroll()">üîÑ Reset Scroll</button>

  <div id="captions"></div>

  <script>
    const gridSize = 22;
    
    let startRow, startCol;
    let stepRow = null, stepCol = null;

 const words = {
  ACADEME: "Where scrolls are born and pedants duel in dusty silence.",
  ACCUSED: "Marked by whispers, but not yet claimed by truth.",
  AMAZEMENT: "The gasp that follows a moonbeam‚Äôs unexpected arrival.",
  COMPROMISE: "A handshake between chaos and calm, sealed with ceremonial socks.",
  DEAFENING: "The silence that screams louder than any outbreak.",
  GNARLED: "Twisted by time, but still rooted in ritual.",
  LAUGHABLE: "When the absurd becomes sacred and socks become scrolls.",
  MADCAP: "The jester‚Äôs sprint through monumental mayhem.",
  MAJESTIC: "Crowned not by gold, but by resilience and mismatched laundry.",
  MIMIC: "A chest you don‚Äôt want to find.",
  MONUMENTAL: "Built from grief, grit, and the bones of canceled plans.",
  MOONBEAM: "A soft rebellion against remorseless nights.",
  NOISELESS: "The hush before the banner rises.",
  OBSCENE: "Too raw for academe, too real for denial.",
  OUTBREAK: "The ritual of masks, scrolls, and sudden pivots.",
  PANDERS: "Whispers that flatter, but never inscribe.",
  PEDANT: "Keeper of rules, challenger of lore.",
  RADIANCE: "The glow that follows a found word.",
  SWAGGER: "The strut of survival in socked feet.",
  REMORSELESS: "Unyielding as grief, sacred as scrollsmith fire."
};


    const puzzle = Array(gridSize * gridSize).fill(null);
    const grid = document.getElementById("grid");
    const captionsDiv = document.getElementById("captions");
    const wordListDiv = document.getElementById("wordList");
    let foundWords = JSON.parse(localStorage.getItem("foundWords")) || [];
    let isDragging = false;
    let selectionPath = [];

    function renderWordList() {
      wordListDiv.innerHTML = "<strong>Words to Find:</strong><br>" + Object.keys(words).map(word => {
        return `<span id="word-${word}" class="${foundWords.includes(word) ? 'foundWord' : ''}">${word}</span>`;
      }).join(", ");
    }

    function updateWordList(word) {
  const el = document.getElementById(`word-${word}`);
  if (el) el.classList.add("foundWord");
}
 function resetScroll() {
  localStorage.removeItem("foundWords");
   document.getElementById("banner").style.display = "none";
  location.reload();
}
   
  function placeWord(word, maxAttempts = 500) {
  const directions = [
  [0, 1],   // right
  [1, 0],   // down
  [0, -1],  // left
  [-1, 0],  // up
  [1, 1],   // down-right
  [-1, -1], // up-left
  [1, -1],  // down-left
  [-1, 1]   // up-right
];

  for (let attempt = 0; attempt < maxAttempts; attempt++) {
    const dir = directions[Math.floor(Math.random() * directions.length)];
    const row = Math.floor(Math.random() * gridSize);
    const col = Math.floor(Math.random() * gridSize);
    let fits = true;
    for (let i = 0; i < word.length; i++) {
      const r = row + dir[0] * i;
      const c = col + dir[1] * i;
      const index = r * gridSize + c;
      if (
        r < 0 || r >= gridSize || c < 0 || c >= gridSize ||
        (puzzle[index] && puzzle[index] !== word[i])
      ) {
        fits = false;
        break;
      }
    }
    if (fits) {
      for (let i = 0; i < word.length; i++) {
        const r = row + dir[0] * i;
        const c = col + dir[1] * i;
        const index = r * gridSize + c;
        puzzle[index] = word[i];
      }
      return true;
    }
  }
  return false;
}
const unplaced = [];

Object.keys(words).forEach(word => {
  const success = placeWord(word);
  if (!success) {
    unplaced.push(word);
    console.warn(`‚ö†Ô∏è Failed to place: ${word}`);
  }
});

unplaced.forEach(word => {
  const success = placeWord(word, 1000);
  if (!success) {
    console.error(`‚ùå Still failed to place: ${word}`);
  }
});

fillEmptyCells();                      // Fill remaining gaps
renderGrid();                          // Display the puzzle
renderWordList();                      // Show word list
foundWords.forEach(updateWordList);   // Restore progress

    function fillEmptyCells() {
  for (let i = 0; i < puzzle.length; i++) {
    if (!puzzle[i]) {
      puzzle[i] = String.fromCharCode(65 + Math.floor(Math.random() * 26));
    }
  }
}
function renderGrid() {
  grid.innerHTML = "";
  for (let i = 0; i < gridSize; i++) {
    const tr = document.createElement("tr");
    for (let j = 0; j < gridSize; j++) {
      const td = document.createElement("td");
      const index = i * gridSize + j;
      td.textContent = puzzle[index];
      td.dataset.row = i;
      td.dataset.col = j;
     td.addEventListener("mousedown", () => handleMouseDown(td));
td.addEventListener("mouseover", () => handleMouseOver(td));
td.addEventListener("mouseup", handleMouseUp);

// üß† Add these for mobile touch support
td.addEventListener("touchstart", (e) => {
  e.preventDefault();
  handleMouseDown(td);
}, { passive: false });

td.addEventListener("touchmove", (e) => {
  e.preventDefault();
  handleMouseOver(td);
}, { passive: false });

td.addEventListener("touchend", (e) => {
  e.preventDefault();
  handleMouseUp();
}, { passive: false });

 tr.appendChild(td);
    }
    grid.appendChild(tr);
  }
}

function handleMouseDown(cell) {
  console.log("Touch activated:", cell.textContent);
  console.log("isDragging set to true");
  isDragging = true;
  selectionPath = [cell];
  cell.classList.add("selected");
  startRow = parseInt(cell.dataset.row);
  startCol = parseInt(cell.dataset.col);
  stepRow = null;
  stepCol = null;
}


function handleMouseOver(cell) {
  if (!isDragging || selectionPath.includes(cell)) return;

  const row = parseInt(cell.dataset.row);
  const col = parseInt(cell.dataset.col);

  if (selectionPath.length === 1) {
    const lastRow = parseInt(selectionPath[0].dataset.row);
    const lastCol = parseInt(selectionPath[0].dataset.col);
    stepRow = Math.sign(row - lastRow);
    stepCol = Math.sign(col - lastCol);

    // Only allow adjacent cell to set direction
    if (Math.abs(row - lastRow) > 1 || Math.abs(col - lastCol) > 1) return;
  }

  const lastCell = selectionPath[selectionPath.length - 1];
  const lastRow = parseInt(lastCell.dataset.row);
  const lastCol = parseInt(lastCell.dataset.col);

  // Enforce strict direction and adjacency
  if (
    row === lastRow + stepRow &&
    col === lastCol + stepCol
  ) {
    selectionPath.push(cell);
    cell.classList.add("selected");
  }
}

function handleMouseUp() {
  if (selectionPath.length < 2) {
    selectionPath.forEach(c => c.classList.remove("selected"));
    selectionPath = [];
    return;
  }

  const getCoords = cell => [
    parseInt(cell.dataset.row),
    parseInt(cell.dataset.col)
  ];

  let valid = true;
  for (let i = 1; i < selectionPath.length; i++) {
    const [prevRow, prevCol] = getCoords(selectionPath[i - 1]);
    const [currRow, currCol] = getCoords(selectionPath[i]);
    const deltaRow = currRow - prevRow;
    const deltaCol = currCol - prevCol;
    if (deltaRow !== stepRow || deltaCol !== stepCol) {
      valid = false;
      break;
    }
  }

  const word = selectionPath.map(c => c.textContent).join("");
  const reversed = word.split("").reverse().join("");
  const found = Object.keys(words).find(w => w === word || w === reversed);

  if (valid && found && !foundWords.includes(found)) {
    foundWords.push(found);
    localStorage.setItem("foundWords", JSON.stringify(foundWords));
    updateWordList(found);
    selectionPath.forEach(c => {
      c.classList.remove("selected");
      c.classList.add("found");
    });
    captionsDiv.innerHTML += `<div class="caption">${words[found]}</div>`;
   //Reveal the banner only when all words are found 
    if (foundWords.length === Object.keys(words).length) {
    document.getElementById("banner").style.display = "block";
  }
  } else {
    // Clear selection if word is invalid
    selectionPath.forEach(c => c.classList.remove("selected"));
  }

  selectionPath = [];
}



//document.body.onmousedown = () => false;
 

      </script>
</body>
</html>

