<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>The Scroll of Monumental Mayhem</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      text-align: center;
      background: #fdf6e3;
      color: #333;
      -webkit-user-select: none;
      user-select: none;
      margin: 0;
      padding: 1rem;
    }

    #gridWrapper {
      overflow-x: auto;
      max-width: 100vw;
      margin: 0 auto 1rem;
      -webkit-overflow-scrolling: touch;
      touch-action: pan-y;
    }

    #grid {
      display: block;
      width: max-content;
      border-collapse: collapse;
      margin: 0 auto;
      touch-action: none;
    }

    /* HIDE GRID LINES: removed border on table cells so the board appears without lines */
    #grid td {
      border: none;
      background: #fff;
      text-align: center;
      vertical-align: middle;
      box-sizing: border-box;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
      cursor: pointer;
      padding: 0;
    }

    .selected { background-color: #cce5ff; }
    .found { background-color: #b2f2bb; font-weight: bold; }
    .foundWord { text-decoration: line-through; color: #999; }

    h1 { font-size: 1.25rem; margin: 0.5rem 0; }
    p { margin: 0.25rem 0 0.75rem; }
    button { padding: 0.5rem 0.75rem; font-size: 1rem; border-radius: 6px; }

    @media (max-width: 420px) { h1 { font-size: 1rem; } }
  </style>
</head>
<body>
  <h1>The Scroll of Monumental Mayhem</h1>
  <p>Tap and drag to trace a word. Progress is saved.</p>

  <div id="wordList"></div>

  <div id="gridWrapper" aria-label="Word search grid wrapper">
    <table id="grid" role="grid" aria-label="Word search grid"></table>
  </div>

  <div id="banner" style="display: none;">üß¶ You‚Äôve earned your ceremonial socks and scrollsmith badge. Onward to the next ritual.</div>
  <button onclick="resetScroll()">üîÑ Reset Scroll</button>
  <div id="captions"></div>

  <script>
    const gridSize = 22;
    const words = { ACADEME: "Where scrolls are born and pedants duel in dusty silence.", ACCUSED: "Marked by whispers, but not yet claimed by truth.", AMAZEMENT: "The gasp that follows a moonbeam‚Äôs unexpected arrival.", COMPROMISE: "A handshake between chaos and calm, sealed with ceremonial socks.", DEAFENING: "The silence that screams louder than any outbreak.", GNARLED: "Twisted by time, but still rooted in ritual.", LAUGHABLE: "When the absurd becomes sacred and socks become scrolls.", MADCAP: "The jester‚Äôs sprint through monumental mayhem.", MAJESTIC: "Crowned not by gold, but by resilience and mismatched laundry.", MIMIC: "A chest you don‚Äôt want to find.", MONUMENTAL: "Built from grief, grit, and the bones of canceled plans.", MOONBEAM: "A soft rebellion against remorseless nights.", NOISELESS: "The hush before the banner rises.", OBSCENE: "Too raw for academe, too real for denial.", OUTBREAK: "The ritual of masks, scrolls, and sudden pivots.", PANDERS: "Whispers that flatter, but never inscribe.", PEDANT: "Keeper of rules, challenger of lore.", RADIANCE: "The glow that follows a found word.", SWAGGER: "The strut of survival in socked feet.", REMORSELESS: "Unyielding as grief, sacred as scrollsmith fire." };

    const puzzle = Array(gridSize * gridSize).fill(null);
    const grid = document.getElementById("grid");
    const gridWrapper = document.getElementById("gridWrapper");
    const wordListDiv = document.getElementById("wordList");
    let foundWords = JSON.parse(localStorage.getItem("foundWords")) || [];
    let isDragging = false; let selectionPath = []; let stepRow = null, stepCol = null;

    function renderWordList() { wordListDiv.innerHTML = "<strong>Words to Find:</strong><br>" + Object.keys(words).map(word => `<span id=\"word-${word}\" class=\"${foundWords.includes(word) ? 'foundWord' : ''}\">${word}</span>`).join(", "); }
    function updateWordList(word) { const el = document.getElementById(`word-${word}`); if (el) el.classList.add("foundWord"); }
    function resetScroll() { localStorage.removeItem("foundWords"); document.getElementById("banner").style.display = "none"; location.reload(); }

    function placeWord(word, maxAttempts = 500) { const directions = [[0,1],[1,0],[0,-1],[-1,0],[1,1],[-1,-1],[1,-1],[-1,1]]; for (let attempt=0; attempt<maxAttempts; attempt++) { const dir = directions[Math.floor(Math.random()*directions.length)]; const row = Math.floor(Math.random()*gridSize); const col = Math.floor(Math.random()*gridSize); let fits=true; for (let i=0;i<word.length;i++){ const r=row+dir[0]*i; const c=col+dir[1]*i; const index=r*gridSize+c; if (r<0||r>=gridSize||c<0||c>=gridSize||(puzzle[index]&&puzzle[index]!==word[i])){fits=false;break;} } if(fits){ for(let i=0;i<word.length;i++){ const r=row+dir[0]*i; const c=col+dir[1]*i; puzzle[r*gridSize+c]=word[i]; } return true; } } return false; }

    const unplaced = [];
    Object.keys(words).forEach(word => { if (!placeWord(word)) { unplaced.push(word); console.warn(`‚ö†Ô∏è Failed to place: ${word}`); } });
    unplaced.forEach(word => { if (!placeWord(word, 1000)) console.error(`‚ùå Still failed to place: ${word}`); });

    function fillEmptyCells() { for (let i=0;i<puzzle.length;i++){ if (!puzzle[i]) puzzle[i]=String.fromCharCode(65+Math.floor(Math.random()*26)); } }

    function renderGrid() { grid.innerHTML = ""; for (let i=0;i<gridSize;i++){ const tr=document.createElement('tr'); for (let j=0;j<gridSize;j++){ const td=document.createElement('td'); td.textContent = puzzle[i*gridSize+j]; td.dataset.row=i; td.dataset.col=j; tr.appendChild(td); } grid.appendChild(tr); } }

    function recomputeGridSize(){ if(!grid||!gridWrapper) return; const padding=12; const availableWidth=Math.max(160, Math.min(window.innerWidth - padding, gridWrapper.clientWidth || window.innerWidth - padding)); const cellSize=Math.max(12, Math.floor(availableWidth / gridSize)); const fontSize=Math.max(10, Math.floor(cellSize * 0.55)); grid.querySelectorAll('td').forEach(td=>{ td.style.width=cellSize+'px'; td.style.height=cellSize+'px'; td.style.fontSize=fontSize+'px'; td.style.lineHeight=cellSize+'px'; }); }
    function debounce(fn,wait){ let t; return function(){ clearTimeout(t); t=setTimeout(()=>fn.apply(this,arguments),wait); }; }

    grid.addEventListener('pointerdown', function(e){ const cell = e.target.closest('td'); if(!cell) return; e.preventDefault(); gridWrapper.style.overflow='hidden'; if (typeof cell.setPointerCapture === 'function') try{ cell.setPointerCapture(e.pointerId); }catch(_){} handleMouseDown(cell); });
    grid.addEventListener('pointermove', function(e){ if(!isDragging) return; const cell = document.elementFromPoint(e.clientX, e.clientY)?.closest?.('td') || e.target.closest('td'); if(!cell) return; handleMouseOver(cell); });
    grid.addEventListener('pointerup', function(e){ gridWrapper.style.overflow=''; handleMouseUp(); });
    grid.addEventListener('pointercancel', function(e){ gridWrapper.style.overflow=''; handleMouseUp(); });

    function handleMouseDown(cell){ isDragging=true; selectionPath=[cell]; cell.classList.add('selected'); stepRow=null; stepCol=null; }
    function handleMouseOver(cell){ if(!isDragging||selectionPath.includes(cell)) return; const row=parseInt(cell.dataset.row,10); const col=parseInt(cell.dataset.col,10); if(selectionPath.length===1){ const lastRow=parseInt(selectionPath[0].dataset.row,10); const lastCol=parseInt(selectionPath[0].dataset.col,10); stepRow=Math.sign(row-lastRow); stepCol=Math.sign(col-lastCol); if(Math.abs(row-lastRow)>1||Math.abs(col-lastCol)>1) return; } const lastCell=selectionPath[selectionPath.length-1]; const lastRow=parseInt(lastCell.dataset.row,10); const lastCol=parseInt(lastCell.dataset.col,10); if(row===lastRow+stepRow && col===lastCol+stepCol){ selectionPath.push(cell); cell.classList.add('selected'); } }

    function handleMouseUp(){ if(!isDragging) return; isDragging=false; if(selectionPath.length<2){ selectionPath.forEach(c=>c.classList.remove('selected')); selectionPath=[]; return; } const getCoords = cell => [parseInt(cell.dataset.row,10), parseInt(cell.dataset.col,10)]; let valid=true; for(let i=1;i<selectionPath.length;i++){ const [pR,pC]=getCoords(selectionPath[i-1]); const [cR,cC]=getCoords(selectionPath[i]); if(cR-pR!==stepRow||cC-pC!==stepCol){ valid=false; break; } } const word = selectionPath.map(c=>c.textContent).join(''); const reversed = word.split('').reverse().join(''); const found = Object.keys(words).find(w=>w===word||w===reversed); if(valid && found && !foundWords.includes(found)){ foundWords.push(found); localStorage.setItem('foundWords', JSON.stringify(foundWords)); updateWordList(found); selectionPath.forEach(c=>{ c.classList.remove('selected'); c.classList.add('found'); }); } else { selectionPath.forEach(c=>c.classList.remove('selected')); } selectionPath=[]; }

    fillEmptyCells(); renderGrid(); window.addEventListener('load', recomputeGridSize); window.addEventListener('resize', debounce(recomputeGridSize,120)); window.addEventListener('orientationchange', recomputeGridSize); recomputeGridSize(); renderWordList(); foundWords.forEach(updateWordList);
  </script>
</body>
</html>