<!-- This is a shortened preview. The full code includes:
- Directional tracing logic (start and end click)
- Word validation across 8 directions
- Local storage to save found words
- Lore captions and final banner reveal
-->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>The Scroll of Monumental Mayhem</title>
  <style>
    /* Styling omitted for brevityâ€”same as previous version */
  </style>
</head>
<body>
  <h1>The Scroll of Monumental Mayhem</h1>
  <p>Click the first and last letter of a word to trace it. Progress is saved.</p>
  <div id="wordList"></div>
  <table id="grid"></table>
  <div id="banner">ðŸ§¦ Youâ€™ve earned your ceremonial socks and scrollsmith badge. Onward to the next ritual.</div>
  <div id="captions"></div>

  <script>
    const words = {
      ACADEME: "...",
      ACCUSED: "...",
      AMAZEMENT: "...",
      // All 20 words with captions
    };

    const gridSize = 25;
    const grid = Array.from({ length: gridSize }, () => Array(gridSize).fill(''));
    const table = document.getElementById("grid");
    const captionsDiv = document.getElementById("captions");
    const wordListDiv = document.getElementById("wordList");
    let foundWords = JSON.parse(localStorage.getItem("foundWords")) || [];
    let startCell = null;

    function renderWordList() {
      wordListDiv.innerHTML = "<strong>Words to Find:</strong><br>" + Object.keys(words).map(word => {
        return `<span id="word-${word}" class="${foundWords.includes(word) ? 'foundWord' : ''}">${word}</span>`;
      }).join(", ");
    }

    function updateWordList(word) {
      const el = document.getElementById(`word-${word}`);
      if (el) el.classList.add("foundWord");
    }

    function placeWord(word) {
      // Same placement logic as before
    }

    Object.keys(words).forEach(word => placeWord(word));

    // Fill empty cells
    for (let i = 0; i < gridSize; i++) {
      for (let j = 0; j < gridSize; j++) {
        if (!grid[i][j]) {
          grid[i][j] = String.fromCharCode(65 + Math.floor(Math.random() * 26));
        }
      }
    }

    // Render grid
    grid.forEach((row, i) => {
      const tr = document.createElement("tr");
      row.forEach((letter, j) => {
        const td = document.createElement("td");
        td.textContent = letter;
        td.dataset.row = i;
        td.dataset.col = j;
        
        td.addEventListener("mousedown", () => handleMouseDown(td));
        td.addEventListener("mouseover", () => handleMouseOver(td));
        td.addEventListener("mouseup", handleMouseUp);
        
        tr.appendChild(td);
      });
      table.appendChild(tr);
    });

    let isDragging = false;
let selectionPath = [];

function handleMouseDown(cell) {
  isDragging = true;
  selectionPath = [cell];
  cell.classList.add("selected");
}

function handleMouseOver(cell) {
  if (isDragging && !selectionPath.includes(cell)) {
    selectionPath.push(cell);
    cell.classList.add("selected");
  }
}


    updateWordList(word);
    if (foundWords.length === Object.keys(words).length) {
      document.getElementById("banner").style.display = "block";
    }
  } else {
    selectionPath.forEach(c => c.classList.remove("selected"));
  }
  selectionPath = [];
}

// Update grid rendering to use drag events
grid.forEach((row, i) => {
  const tr = document.createElement("tr");
  row.forEach((letter, j) => {
    const td = document.createElement("td");
    td.textContent = letter;
    td.dataset.row = i;
    td.dataset.col = j;
    td.addEventListener("mousedown", () => handleMouseDown(td));
    td.addEventListener("mouseover", () => handleMouseOver(td));
    td.addEventListener("mouseup", handleMouseUp);
    tr.appendChild(td);
  });
  table.appendChild(tr);
});

// Prevent text selection during drag
document.body.onmousedown = () => false;

      }
    }

    function getPath(start, end) {
      const r1 = parseInt(start.dataset.row);
      const c1 = parseInt(start.dataset.col);
      const r2 = parseInt(end.dataset.row);
      const c2 = parseInt(end.dataset.col);
      const dr = r2 - r1;
      const dc = c2 - c1;
      const len = Math.max(Math.abs(dr), Math.abs(dc)) + 1;
      const stepR = dr === 0 ? 0 : dr / (len - 1);
      const stepC = dc === 0 ? 0 : dc / (len - 1);
      const path = [];
      for (let i = 0; i < len; i++) {
        const r = Math.round(r1 + stepR * i);
        const c = Math.round(c1 + stepC * i);
        const cell = document.querySelector(`td[data-row='${r}'][data-col='${c}']`);
        if (cell) path.push(cell);
      }
      return path;
    }

    // Restore found words
    foundWords.forEach(word => {
      updateWordList(word);
      Object.keys(words).forEach(w => {
        if (w === word) {
          // Optional: highlight found word path
        }
      });
    });

    renderWordList();
  </script>
</body>
</html>

