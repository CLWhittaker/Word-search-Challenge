<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>The Scroll of Monumental Mayhem</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{ --cell-size: 36px; --cell-gap: 2px; }
    html,body{height:100%}
    body {
      font-family: 'Segoe UI', Roboto, system-ui, -apple-system, sans-serif;
      text-align: center;
      background: #fdf6e3;
      color: #333;
      -webkit-user-select: none;
      user-select: none;
      margin: 0;
      padding: 1rem;
      box-sizing: border-box;
    }

    #gridWrapper {
      overflow-x: auto;
      max-width: 100vw;
      margin: 0 auto 1rem;
      -webkit-overflow-scrolling: touch;
      touch-action: pan-y;
      border-radius: 8px;
      padding: 6px;
      background: transparent;
    }

    /* Keep using table layout for semantic grid; will size cells via inline style */
    #grid {
      display: inline-table;
      border-collapse: collapse;
      border-spacing: 0;
      margin: 0 auto;
      touch-action: none;
      background: transparent;
      user-select: none;
    }

    #grid td {
      background: #fff;
      text-align: center;
      vertical-align: middle;
      box-sizing: border-box;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
      cursor: pointer;
      padding: 0;
      outline: none;
      border-radius: 6px;
      transition: background-color 140ms, transform 80ms, box-shadow 200ms;
      font-weight: 600;
      font-size: 0.9rem;
      width: var(--cell-size);
      height: var(--cell-size);
      line-height: var(--cell-size);
      margin: var(--cell-gap);
      display: table-cell;
    }

    .selected { background-color: #cce5ff; transform: scale(1.02); }
    /* stronger persistent found style: distinct color, outline, and subtle glow */
    .found {
      background: linear-gradient(180deg,#daf7d7 0%, #b2f2bb 100%);
      color: #0a4b11;
      box-shadow: inset 0 0 0 3px rgba(6,78,18,0.12), 0 6px 14px rgba(6,78,18,0.06);
      border: 1px solid #0a4b11;
      transform: none;
    }

    .foundWord { text-decoration: line-through; color: #666; display: inline-block; margin:0.15rem 0.4rem; font-weight:700 }

    h1 { font-size: 1.25rem; margin: 0.5rem 0; }
    p { margin: 0.25rem 0 0.75rem; }
    button { padding: 0.5rem 0.75rem; font-size: 1rem; border-radius: 6px; }

    #wordList { margin-bottom: 0.5rem; }
    #banner { margin: 0.75rem 0; padding: 0.5rem; background: #fff8dc; border-radius: 6px; display:none; }

    @media (max-width: 420px) {
      h1 { font-size: 1rem; }
      :root{ --cell-size: 30px; }
      #grid td { font-size: 0.8rem; }
    }
  </style>
</head>
<body>
  <h1>The Scroll of Monumental Mayhem</h1>
  <p>Tap and drag to trace a word. Progress is saved.</p>

  <div id="wordList" aria-live="polite"></div>

  <div id="gridWrapper" aria-label="Word search grid wrapper">
    <table id="grid" role="grid" aria-label="Word search grid"></table>
  </div>

  <div id="banner">ðŸ§¦ Youâ€™ve earned your ceremonial socks and scrollsmith badge. Onward to the next ritual.</div>
  <button id="resetBtn">ðŸ”„ Reset Scroll</button>
  <div id="captions" style="margin-top:0.5rem;color:#666;font-size:0.9rem"></div>

  <script>
    // CONFIG
    const gridSize = 22;
    // 20 words with sentence shown when found
    const words = {
      ACADEME: "Where scrolls are born and pedants duel in dusty silence.",
      ACCUSED: "Marked by whispers, but not yet claimed by truth.",
      AMAZEMENT: "The gasp that follows a moonbeam's surprise.",
      SCRIPT: "A line of runes that binds a thought.",
      MAVERICK: "One who wanders off the expected map.",
      RITUAL: "Small repeated acts make a rite of the mundane.",
      SCRIPTORIUM: "A quiet room where ink drinks stories.",
      RUNES: "Ancient marks that hum with meaning.",
      LORE: "A map of memory passed by lantern-light.",
      CITADEL: "Stone shoulders that keep a city's secrets.",
      VIGIL: "A watch kept for promises and stars.",
      SERPENT: "A winding shadow between the roots.",
      CONSTELLATION: "Patterns of intent stitched across night.",
      ODYSSEY: "A long trail of small discoveries.",
      QUILL: "A feather that leaves a permanent trail.",
      EMBER: "Heat that remembers the fire's name.",
      PHOENIX: "A promise that endings are unfinished beginnings.",
      ENCYCLOPEDIA: "A tower of answers built from other people's searches.",
      HARBINGER: "The quiet herald of change's first knock.",
      ARCANUM: "A single secret wrapped in careful language."
    };

    // State
    const puzzle = new Array(gridSize * gridSize).fill(null);
    const placements = {};
    // store foundWords set and also foundPositions map for exact indices per word
    const foundWords = new Set(JSON.parse(localStorage.getItem("foundWords") || "[]"));
    const foundPositions = JSON.parse(localStorage.getItem("foundPositions") || "{}");

    const grid = document.getElementById('grid');
    const gridWrapper = document.getElementById('gridWrapper');
    const wordListDiv = document.getElementById('wordList');
    const banner = document.getElementById('banner');
    const captions = document.getElementById('captions');

    // Utility
    function idx(row, col){ return row * gridSize + col; }
    function rc(index){ return [Math.floor(index / gridSize), index % gridSize]; }
    function randInt(n){ return Math.floor(Math.random() * n); }

    // Place words into puzzle
    function placeWord(word, maxAttempts = 1000) {
      const dirs = [[0,1],[1,0],[0,-1],[-1,0],[1,1],[-1,-1],[1,-1],[-1,1]];
      const L = word.length;
      for (let attempt=0; attempt<maxAttempts; attempt++){
        const dir = dirs[randInt(dirs.length)];
        const dr=dir[0], dc=dir[1];
        let r = randInt(gridSize);
        let c = randInt(gridSize);

        const endR = r + dr*(L-1);
        const endC = c + dc*(L-1);
        if (endR < 0 || endR >= gridSize || endC < 0 || endC >= gridSize) continue;

        // check collisions
        let path = [];
        let ok = true;
        for (let k=0;k<L;k++){
          const rr = r + dr*k, cc = c + dc*k;
          const i = idx(rr,cc);
          const ch = puzzle[i];
          if (ch && ch !== word[k]) { ok = false; break; }
          path.push(i);
        }
        if (!ok) continue;

        // place
        for (let k=0;k<L;k++){
          puzzle[path[k]] = word[k];
        }
        placements[word] = path;
        return true;
      }
      return false;
    }

    function fillEmptyCells(){
      for (let i=0;i<puzzle.length;i++){
        if (!puzzle[i]) puzzle[i] = String.fromCharCode(65 + randInt(26));
      }
    }

    // Render word list
    function renderWordList(){
      const keys = Object.keys(words);
      wordListDiv.innerHTML = '<strong>Words to Find:</strong><br>';
      keys.forEach(w => {
        const span = document.createElement('span');
        span.id = `word-${w}`;
        span.textContent = w;
        if (foundWords.has(w)) span.classList.add('foundWord');
        span.title = words[w] || '';
        wordListDiv.appendChild(span);
        wordListDiv.appendChild(document.createTextNode(' '));
      });
    }

    // Build grid DOM
    function renderGrid(){
      grid.innerHTML = '';
      for (let r=0;r<gridSize;r++){
        const tr = document.createElement('tr');
        for (let c=0;c<gridSize;c++){
          const td = document.createElement('td');
          td.setAttribute('role','gridcell');
          td.dataset.row = r;
          td.dataset.col = c;
          td.dataset.index = idx(r,c);
          td.textContent = puzzle[idx(r,c)];
          if (isCellInFound(idx(r,c))) td.classList.add('found');
          tr.appendChild(td);
        }
        grid.appendChild(tr);
      }
    }

    function isCellInFound(i){
      // first check foundPositions as authoritative
      for (const w in foundPositions){
        const arr = foundPositions[w] || [];
        if (arr.indexOf(i) !== -1) return true;
      }
      // fallback to placements
      for (const w of foundWords){
        const path = placements[w];
        if (!path) continue;
        if (path.indexOf(i) !== -1) return true;
      }
      return false;
    }

    // Responsive sizing (fit full grid if possible)
    function recomputeGridSize(){
      const padding = 24;
      const availableWidth = Math.max(120, Math.min(window.innerWidth - padding, gridWrapper.clientWidth || window.innerWidth - padding));
      let target = Math.floor(availableWidth / gridSize);
      const minSize = 20;
      const maxSize = 52;
      if (target < minSize) target = minSize;
      if (target > maxSize) target = maxSize;
      document.documentElement.style.setProperty('--cell-size', target + 'px');
    }

    // Selection with pointer events
    let isDragging = false;
    let selection = [];
    let startCell = null;
    let lastAdded = null;

    function clearSelection(){
      selection.forEach(td => td.classList.remove('selected'));
      selection = [];
      startCell = lastAdded = null;
    }

    function addToSelection(td){
      if (!td || selection.includes(td)) return;
      if (!startCell){
        startCell = td;
        selection.push(td);
        td.classList.add('selected');
        lastAdded = td;
        return;
      }
      const sr = parseInt(startCell.dataset.row,10);
      const sc = parseInt(startCell.dataset.col,10);
      const r = parseInt(td.dataset.row,10);
      const c = parseInt(td.dataset.col,10);
      const dr = r - sr;
      const dc = c - sc;
      const g = gcd2(Math.abs(dr), Math.abs(dc));
      if (g === 0) return;
      const stepR = dr / g;
      const stepC = dc / g;

      const path = [];
      for (let k=0;k<=g;k++){
        const rr = sr + stepR * k;
        const cc = sc + stepC * k;
        const el = grid.querySelector(`td[data-row="${rr}"][data-col="${cc}"]`);
        if (!el) return;
        path.push(el);
      }

      selection.forEach(e => e.classList.remove('selected'));
      selection = path.slice();
      selection.forEach(e => e.classList.add('selected'));
      lastAdded = td;
    }

    function gcd2(a,b){ if(!a) return b; if(!b) return a; while(b){ const t=a%b; a=b; b=t; } return a; }

    // mark cells as found (accepts indices array or uses placements)
    function markCellsFoundByWord(word, indices){
      const path = indices || placements[word] || [];
      path.forEach(i => {
        const [r,c] = rc(i);
        const td = grid.querySelector(`td[data-row="${r}"][data-col="${c}"]`);
        if (td){
          td.classList.add('found');
          td.classList.remove('selected');
          td.dataset.found = word;
        }
      });
    }

    function finalizeSelection(){
      if (!selection || selection.length < 2){ clearSelection(); return; }
      const letters = selection.map(td=>td.textContent).join('');
      const lettersRev = selection.map(td=>td.textContent).reverse().join('');
      let matched = null;
      if (Object.keys(words).includes(letters)) matched = letters;
      else if (Object.keys(words).includes(lettersRev)) matched = lettersRev;

      if (matched && !foundWords.has(matched)){
        foundWords.add(matched);
        localStorage.setItem('foundWords', JSON.stringify(Array.from(foundWords)));

        // Persist the exact indices of the successful selection â€” ensures mobile highlight reliability
        const selIndices = selection.map(td => parseInt(td.dataset.index,10));
        foundPositions[matched] = selIndices;
        localStorage.setItem('foundPositions', JSON.stringify(foundPositions));

        // Immediately mark those cells as found so mobile shows highlight right away
        markCellsFoundByWord(matched, selIndices);

        const el = document.getElementById(`word-${matched}`);
        if (el) el.classList.add('foundWord');

        // Show the sentence associated with the found word
        captions.textContent = `${matched} â€” ${words[matched] || ''}`;

        if (Object.keys(words).every(w=>foundWords.has(w))){
          banner.style.display = 'block';
        }
      } else {
        selection.forEach(td => td.classList.remove('selected'));
      }
      selection = [];
      startCell = lastAdded = null;
    }

    // Pointer & touch event handlers (replace the existing pointer handlers with this block)
    // Adds logging + touch fallback for devices that drop pointer events.
    function reportSelection(tag){
      try {
        const indices = selection.map(td => parseInt(td.dataset.index,10));
        const letters = selection.map(td => td.textContent).join('');
        console.log(`[grid] ${tag}`, {count: selection.length, indices, letters});
      } catch(e) { console.log('[grid] reportSelection error', e); }
    }

    grid.addEventListener('pointerdown', function(e){
      const td = e.target.closest('td');
      if (!td) return;
      e.preventDefault();
      grid.setPointerCapture && grid.setPointerCapture(e.pointerId);
      isDragging = true;
      gridWrapper.style.overflow = 'hidden';
      clearSelection();
      addToSelection(td);
      reportSelection('pointerdown');
    }, {passive:false});

    grid.addEventListener('pointermove', function(e){
      if (!isDragging) return;
      const el = document.elementFromPoint(e.clientX, e.clientY);
      const td = el && el.closest ? el.closest('td') : null;
      if (!td) return;
      addToSelection(td);
      reportSelection('pointermove');
    }, {passive:false});

    grid.addEventListener('pointerup', function(e){
      if (!isDragging) return;
      try { grid.releasePointerCapture && grid.releasePointerCapture(e.pointerId); } catch {}
      isDragging = false;
      gridWrapper.style.overflow = '';
      reportSelection('pointerup-before-finalize');
      finalizeSelection();
    }, {passive:false});

    grid.addEventListener('pointercancel', function(e){
      if (!isDragging) return;
      try { grid.releasePointerCapture && grid.releasePointerCapture(e.pointerId); } catch {}
      isDragging = false;
      gridWrapper.style.overflow = '';
      clearSelection();
      reportSelection('pointercancel');
    }, {passive:false});

    // Touch fallbacks for browsers that prefer touch events (Android Chrome sometimes behaves better with explicit touch handlers)
    grid.addEventListener('touchstart', function(e){
      const t = e.touches && e.touches[0];
      if (!t) return;
      e.preventDefault();
      const el = document.elementFromPoint(t.clientX, t.clientY);
      const td = el && el.closest ? el.closest('td') : null;
      if (!td) return;
      isDragging = true;
      gridWrapper.style.overflow = 'hidden';
      clearSelection();
      addToSelection(td);
      reportSelection('touchstart');
    }, {passive:false});

    grid.addEventListener('touchmove', function(e){
      if (!isDragging) return;
      const t = e.touches && e.touches[0];
      if (!t) return;
      const el = document.elementFromPoint(t.clientX, t.clientY);
      const td = el && el.closest ? el.closest('td') : null;
      if (!td) return;
      addToSelection(td);
      reportSelection('touchmove');
    }, {passive:false});

    grid.addEventListener('touchend', function(e){
      if (!isDragging) return;
      // Try to add last touch position (use changedTouches)
      const t = e.changedTouches && e.changedTouches[0];
      if (t){
        const el = document.elementFromPoint(t.clientX, t.clientY);
        const td = el && el.closest ? el.closest('td') : null;
        if (td) addToSelection(td);
      }
      isDragging = false;
      gridWrapper.style.overflow = '';
      reportSelection('touchend-before-finalize');
      finalizeSelection();
    }, {passive:false});

    document.getElementById('resetBtn').addEventListener('click', function(){
      localStorage.removeItem('foundWords');
      localStorage.removeItem('foundPositions');
      foundWords.clear();
      for (const k in foundPositions) delete foundPositions[k];
      banner.style.display = 'none';
      location.reload();
    });

    (function init(){
      for (let i=0;i<puzzle.length;i++) puzzle[i] = null;
      Object.keys(words).forEach(w => delete placements[w]);

      const wordKeys = Object.keys(words).sort((a,b)=>b.length - a.length);
      const unplaced = [];
      wordKeys.forEach(w => { if (!placeWord(w)) unplaced.push(w); });
      if (unplaced.length){ unplaced.forEach(w => { if (!placeWord(w, 3000)) console.warn('Failed to place', w); }); }
      fillEmptyCells();
      renderGrid();
      renderWordList();

      // re-apply found highlight from localStorage using saved positions first
      Object.keys(foundPositions).forEach(w => {
        const indices = foundPositions[w] || [];
        if (indices.length) markCellsFoundByWord(w, indices);
        const el = document.getElementById(`word-${w}`);
        if (el) el.classList.add('foundWord');
      });

      // fallback: if foundWords exists but foundPositions missing, try to use placements
      Array.from(foundWords).forEach(w => {
        if (!foundPositions[w]){
          const path = placements[w];
          if (path) markCellsFoundByWord(w, path);
          const el = document.getElementById(`word-${w}`);
          if (el) el.classList.add('foundWord');
        }
      });

      if (Object.keys(words).every(w=>foundWords.has(w))){ banner.style.display = 'block'; }

      recomputeGridSize();
      window.addEventListener('resize', debounce(recomputeGridSize, 120));
      window.addEventListener('orientationchange', debounce(recomputeGridSize, 120));
    })();

    // tiny debounce
    function debounce(fn, wait){ let t; return function(){ clearTimeout(t); t=setTimeout(()=>fn.apply(this,arguments), wait); }; }
  </script>
</body>
</html>
