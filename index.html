<!-- This is a shortened preview. The full code includes:
- Directional tracing logic (start and end click)
- Word validation across 8 directions
- Local storage to save found words
- Lore captions and final banner reveal
-->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>The Scroll of Monumental Mayhem</title>
  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      text-align: center;
      background: #fdf6e3;
      color: #333;
    }
    #grid {
      margin: 20px auto;
      border-collapse: collapse;
    }
    #grid td {
      width: 24px;
      height: 24px;
      border: 1px solid #ccc;
      text-align: center;
      font-size: 16px;
      cursor: pointer;
    }
    .selected {
      background-color: #cce5ff;
    }
    .found {
      background-color: #b2f2bb;
      font-weight: bold;
    }
    .foundWord {
      text-decoration: line-through;
      color: #999;
    }
    #banner {
      display: none;
      margin-top: 20px;
      font-size: 18px;
      color: #007700;
    }
    .caption {
      margin-top: 10px;
      font-style: italic;
    }
  </style>
</head>
<body>
  <h1>The Scroll of Monumental Mayhem</h1>
  <p>Click and drag to trace a word. Progress is saved.</p>
  <div id="wordList"></div>
  <table id="grid"></table>
  <div id="banner">ðŸ§¦ Youâ€™ve earned your ceremonial socks and scrollsmith badge. Onward to the next ritual.</div>
  <div id="captions"></div>

  <script>
    const gridSize = 25;
    
 const words = {
  ACADEME: "Where scrolls are born and pedants duel in dusty silence.",
  ACCUSED: "Marked by whispers, but not yet claimed by truth.",
  AMAZEMENT: "The gasp that follows a moonbeamâ€™s unexpected arrival.",
  COMPROMISE: "A handshake between chaos and calm, sealed with ceremonial socks.",
  DEAFENING: "The silence that screams louder than any outbreak.",
  GNARLED: "Twisted by time, but still rooted in ritual.",
  LAUGHABLE: "When the absurd becomes sacred and socks become scrolls.",
  MADCAP: "The jesterâ€™s sprint through monumental mayhem.",
  MAJESTIC: "Crowned not by gold, but by resilience and mismatched laundry.",
  MIMIC: "A chest you donâ€™t want to find.",
  MONUMENTAL: "Built from grief, grit, and the bones of canceled plans.",
  MOONBEAM: "A soft rebellion against remorseless nights.",
  NOISELESS: "The hush before the banner rises.",
  OBSCENE: "Too raw for academe, too real for denial.",
  OUTBREAK: "The ritual of masks, scrolls, and sudden pivots.",
  PANDERS: "Whispers that flatter, but never inscribe.",
  PEDANT: "Keeper of rules, challenger of lore.",
  RADIANCE: "The glow that follows a found word.",
  SWAGGER: "The strut of survival in socked feet.",
  REMORSELESS: "Unyielding as grief, sacred as scrollsmith fire."
};


    const puzzle = Array(gridSize * gridSize).fill(null);
    const grid = document.getElementById("grid");
    const captionsDiv = document.getElementById("captions");
    const wordListDiv = document.getElementById("wordList");
    let foundWords = JSON.parse(localStorage.getItem("foundWords")) || [];
    let isDragging = false;
    let selectionPath = [];

    function renderWordList() {
      wordListDiv.innerHTML = "<strong>Words to Find:</strong><br>" + Object.keys(words).map(word => {
        return `<span id="word-${word}" class="${foundWords.includes(word) ? 'foundWord' : ''}">${word}</span>`;
      }).join(", ");
    }

    function updateWordList(word) {
  const el = document.getElementById(`word-${word}`);
  if (el) el.classList.add("foundWord");
}
  function placeWord(word) {
  const directions = [
    [0, 1], [1, 0], [1, 1], [-1, 1]
  ];
  for (let attempt = 0; attempt < 100; attempt++) {
    const dir = directions[Math.floor(Math.random() * directions.length)];
    const row = Math.floor(Math.random() * gridSize);
    const col = Math.floor(Math.random() * gridSize);
    let fits = true;
    for (let i = 0; i < word.length; i++) {
      const r = row + dir[0] * i;
      const c = col + dir[1] * i;
      const index = r * gridSize + c;
      if (r < 0 || r >= gridSize || c < 0 || c >= gridSize || (puzzle[index] && puzzle[index] !== word[i])) {
        fits = false;
        break;
      }
    }
    if (fits) {
      for (let i = 0; i < word.length; i++) {
        const r = row + dir[0] * i;
        const c = col + dir[1] * i;
        const index = r * gridSize + c;
        puzzle[index] = word[i];
      }
      return;
    }
  }
}

    function fillEmptyCells() {
  for (let i = 0; i < puzzle.length; i++) {
    if (!puzzle[i]) {
      puzzle[i] = String.fromCharCode(65 + Math.floor(Math.random() * 26));
    }
  }
}

function renderGrid() {
  for (let i = 0; i < gridSize; i++) {
    const tr = document.createElement("tr");
    for (let j = 0; j < gridSize; j++) {
      const td = document.createElement("td");
      const index = i * gridSize + j;
      td.textContent = puzzle[index];
      td.dataset.row = i;
      td.dataset.col = j;
      td.addEventListener("mousedown", () => handleMouseDown(td));
      td.addEventListener("mouseover", () => handleMouseOver(td));
      td.addEventListener("mouseup", handleMouseUp);
      tr.appendChild(td);
    }
    grid.appendChild(tr);
  }
}

function handleMouseDown(cell) {
  isDragging = true;
  selectionPath = [cell];
  cell.classList.add("selected");
}

function handleMouseOver(cell) {
  if (!isDragging || selectionPath.includes(cell)) return;
  selectionPath.push(cell);
  cell.classList.add("selected");
}

function handleMouseUp() {
  isDragging = false;
  const word = selectionPath.map(c => c.textContent).join("");
  if (words[word] && !foundWords.includes(word)) {
    selectionPath.forEach(c => {
      c.classList.remove("selected");
      c.classList.add("found");
    });
    foundWords.push(word);
    localStorage.setItem("foundWords", JSON.stringify(foundWords));
    const caption = document.createElement("div");
    caption.className = "caption";
    caption.textContent = `${word}: ${words[word]}`;
    captionsDiv.appendChild(caption);
    updateWordList(word);
    if (foundWords.length === Object.keys(words).length) {
      document.getElementById("banner").style.display = "block";
    }
  } else {
    selectionPath.forEach(c => c.classList.remove("selected"));
  }
  selectionPath = [];
}

document.body.onmousedown = () => false;
 
Object.keys(words).forEach(placeWord);
fillEmptyCells();
renderGrid();
renderWordList();
foundWords.forEach(updateWordList);

      </script>
</body>
</html>

